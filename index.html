<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte rayon</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    :root { --bg:#0b1220; --panel:#111a2b; --text:#eef2ff; --muted:#9fb0d9; --accent:#ff4d4f; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1200px;margin:0 auto;padding:24px}
    .card{background:var(--panel);border-radius:16px;padding:18px;box-shadow:0 10px 28px rgba(0,0,0,.25)}
    h1{margin:0 0 8px;font-size:1.4rem}
    label{font-size:.9rem;color:var(--muted);display:block;margin:6px 0}
    input, button{font:inherit}
    input[type="text"], input[type="number"], input[type="color"]{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #243356;background:#0c1531;color:var(--text);outline:none}
    input::placeholder{color:#6f7fb2}
    .grid{display:grid;grid-template-columns:1.1fr .9fr .7fr .7fr;gap:12px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}
    .row{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;align-items:center}
    button{appearance:none;border:0;border-radius:14px;padding:12px 16px;background:var(--accent);color:white;font-weight:700;cursor:pointer;box-shadow:0 8px 18px rgba(255,77,79,.35)}
    button.secondary{background:#2a375a;box-shadow:none;font-weight:600}
    .mapwrap{margin-top:14px;border-radius:14px;overflow:hidden;border:1px solid #203058}
    #map{height:560px;width:100%}
    .small{font-size:.85rem;color:#9db0e2}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .footer{margin-top:8px;color:#7f93ca;font-size:.8rem}
    .poi-grid{display:grid;grid-template-columns:1.2fr .5fr .7fr .9fr;gap:10px;margin:10px 0}
    @media (max-width:900px){.poi-grid{grid-template-columns:1fr 1fr}}
    #poiList{margin-top:6px;display:flex;flex-direction:column;gap:6px}
    .poi-item{display:flex;align-items:center;gap:8px;background:#0c1531;border:1px solid #233355;border-radius:10px;padding:6px 10px}
    .poi-item button{padding:6px 10px}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;border:1px solid #000}
    /* pastille rouge draggable */
    .pin{width:14px;height:14px;border-radius:999px;background:#ff3b30;border:2px solid #ffffff;box-shadow:0 0 0 2px #ff3b30}
    .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#1b2743;border:1px solid #2e3b63;color:#a6b5e5;font-size:.75rem}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Carte rayon</h1>

      <!-- Barre de session collaborative -->
      <div class="row">
        <div style="flex:1;min-width:220px">
          <label for="room">Code de session (ex: MASC-42)</label>
          <input id="room" type="text" placeholder="Entrez un code partagÃ©"/>
        </div>
        <button id="join">CrÃ©er / Rejoindre</button>
        <button id="share" class="secondary" title="Copier un lien de partage">Partager</button>
        <button id="reset" class="secondary" title="RÃ©initialiser la page (quitter la session et tout effacer localement)">RÃ©initialiser</button>
        <span id="roomInfo" class="badge">Hors session</span>
      </div>

      <!-- ContrÃ´les d'adresse/rayon -->
      <div class="grid" style="margin-top:10px">
        <div>
          <label for="addr">Adresse</label>
          <input id="addr" type="text" placeholder="ex. 822 Rue Brien, Mascouche, QC" />
        </div>
        <div>
          <label for="radius">Rayon (mÃ¨tres)</label>
          <input id="radius" type="number" value="300" min="50" max="2000" step="10" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="search">Rechercher et tracer</button>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="export" class="secondary" title="Exporter la vue de carte en PNG">Exporter en PNG</button>
        </div>
      </div>

      <!-- POI -->
      <h2 class="small" style="margin-top:12px;">Points dâ€™intÃ©rÃªt</h2>
      <div class="poi-grid">
        <input id="poiName" type="text" placeholder="Nom du point (optionnel)" />
        <input id="poiColor" type="color" value="#ff3b30" style="width:52px;height:36px;padding:0;border-radius:8px;border:1px solid #243356;background:#0c1531;appearance:none;" />
        <button id="addPoiOnce" class="secondary" title="Ajouter un point en cliquant sur la carte">Ajouter</button>
        <span id="poiHint" class="small" style="color:#9fb0d9"></span>
      </div>
      <div id="poiList" class="small"></div>

      <!-- Couleur -->
      <div class="row" id="drawColorRow" style="margin-top:6px;align-items:center">
        <label for="drawColor" class="small" style="margin-right:8px;">Couleur</label>
        <input id="drawColor" type="color" value="#ffd43b" style="width:52px;height:36px;padding:0;border-radius:8px;border:1px solid #243356;background:#0c1531;" />
      </div>

      <!-- Carte -->
      <div class="mapwrap"><div id="map"></div></div>
      <div class="footer small">Carte Â© <a class="mono" href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap</a>. Tuiles: <span class="mono">tile.openstreetmap.org</span>. Merci de garder lâ€™attribution visible.</div>
      <div class="small" id="status"></div>
    </div>
  </div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <!-- Export helper -->
  <script src="https://unpkg.com/leaflet-image@latest/leaflet-image.js"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script>
  (function(){
    // ====== UI refs ======
    const addrEl = document.getElementById('addr');
    const radiusEl = document.getElementById('radius');
    const searchBtn = document.getElementById('search');
    const exportBtn = document.getElementById('export');
    const resetBtn = document.getElementById('reset');
    const statusEl = document.getElementById('status');

    const poiNameEl = document.getElementById('poiName');
    const poiColorEl = document.getElementById('poiColor');
    const addPoiOnceBtn = document.getElementById('addPoiOnce');
    const poiHintEl = document.getElementById('poiHint');
    const poiListEl = document.getElementById('poiList');
    const drawColorEl = document.getElementById('drawColor');

    const roomEl = document.getElementById('room');
    const joinBtn = document.getElementById('join');
    const roomInfo = document.getElementById('roomInfo');

    function setStatus(t){ statusEl.textContent = t || ''; }

    // ====== Map init ======
    const map = L.map('map', { preferCanvas: true });
    // === Basemaps (clair / sombre / satellite) ===
    const osmLight = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      crossOrigin: true,
      attribution: '&copy; OpenStreetMap contributors'
    });

    const esriDark = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      crossOrigin: true,
      attribution: 'Tiles &copy; Esri â€” Esri, HERE, Garmin, FAO, NOAA, USGS, Â© OpenStreetMap contributors, and the GIS user community'
    });

    const esriLightGray = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      crossOrigin: true,
      attribution: 'Tiles &copy; Esri â€” Esri, HERE, Garmin, FAO, NOAA, USGS, Â© OpenStreetMap contributors, and the GIS user community'
    });

    const esriImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      crossOrigin: true,
      attribution: 'Imagery &copy; Esri, Maxar, Earthstar Geographics, and the GIS user community'
    });

    let currentBase = null;
    function setBase(layer){ if(currentBase){ map.removeLayer(currentBase); } layer.addTo(map); currentBase = layer; }

    // par dÃ©faut: clair (OSM)
    setBase(osmLight);

    // ContrÃ´le de basemap (seulement Clair et Satellite)
    const baseMaps = {
      'Clair (OSM)': osmLight,
      'Satellite (Esri World Imagery)': esriImagery
    };
    L.control.layers(baseMaps, {}, { collapsed: false, position: 'topright' }).addTo(map);

    // Mascouche par dÃ©faut
    map.setView([45.749, -73.601], 13);

    const poiLayer = L.layerGroup().addTo(map);
    const drawLayer = new L.FeatureGroup().addTo(map);

    // === Toolbar par dÃ©faut Leaflet.draw (ligne, polygone, rectangle) + Ã©dition/suppression
    const drawControl = new L.Control.Draw({
      edit: { featureGroup: drawLayer, remove: true },
      draw: {
        polyline:  { shapeOptions: { color: '#ffd43b', weight: 6, opacity: 0.9 } },
        polygon:   { shapeOptions: { color: '#ffd43b', weight: 2, fillColor:'#ffd43b', fillOpacity: 0.3 } },
        rectangle: { shapeOptions: { color: '#ffd43b', weight: 2, fillColor:'#ffd43b', fillOpacity: 0.3 } },
        circle: false, circlemarker: false, marker: false
      }
    });
    map.addControl(drawControl);

    // ====== ContrÃ´le Mesure (mÃ¨tres) ======
    let measuringActive = false;
    let measureDrawer = null;
    let measureBtn = null;

    function distMeters(a,b){
      const R=6371000; const toRad=x=>x*Math.PI/180;
      const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const va=s1*s1 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*s2*s2;
      return 2*R*Math.atan2(Math.sqrt(va), Math.sqrt(1-va));
    }
    function polylineLength(latlngs){
      if(!Array.isArray(latlngs)) return 0;
      let m=0; for(let i=1;i<latlngs.length;i++){ m+=distMeters(latlngs[i-1], latlngs[i]); }
      return m;
    }

    const MeasureControl = L.Control.extend({
      onAdd: function(map){
        const container = L.DomUtil.create('div','leaflet-bar');
        const a = L.DomUtil.create('a','',container);
        a.href = '#'; a.title = 'Mesurer (m)'; a.innerHTML = 'ðŸ“';
        L.DomEvent.on(a,'click',(ev)=>{
          L.DomEvent.stop(ev);
          if(!measureDrawer){
            measureDrawer = new L.Draw.Polyline(map, {
              showLength: true, metric: true,
              shapeOptions: { color:'#ffffff', weight:3, dashArray:'6,4', opacity:1 }
            });
          }
          measuringActive = true;
          a.classList.add('active');
          measureBtn = a;
          // dÃ©sarmer ajout POI si actif
          if (typeof addPoiArmed !== 'undefined' && addPoiArmed){
            addPoiArmed = false;
            const hint = document.getElementById('poiHint');
            if(hint) hint.textContent='';
            const addBtn = document.getElementById('addPoiOnce');
            if(addBtn){ addBtn.textContent='Ajouter'; addBtn.disabled=false; }
          }
          setStatus('Mesure active : cliquez pour tracer, double-cliquez pour terminer, Ã‰chap pour annuler.');
          measureDrawer.enable();
        });
        return container;
      }
    });
    map.addControl(new MeasureControl({ position: 'topleft' }));

    // Appliquer la couleur courante aux outils de dessin
    function applyDrawColor(){
      const c = (drawColorEl && drawColorEl.value) || '#ffd43b';
      drawControl.setDrawingOptions({
        polyline:  { shapeOptions: { color: c, weight: 6, opacity: 0.9 } },
        polygon:   { shapeOptions: { color: c, weight: 2, fillColor: c, fillOpacity: 0.3 } },
        rectangle: { shapeOptions: { color: c, weight: 2, fillColor: c, fillOpacity: 0.3 } }
      });
    }

    // ====== (pas d'Undo/Redo) ======
    let history = []; let histIdx = -1; // gardÃ©s pour compat
    function snapshotDrawings(){}
    function updateUndoRedoButtons(){}

    let addPoiArmed = false; if(poiHintEl) poiHintEl.textContent=''; if(addPoiOnceBtn){ addPoiOnceBtn.textContent='Ajouter'; addPoiOnceBtn.disabled=false; }

    let centerMarker = null; // centre
    let circle = null;       // cercle
    let pois = [];

    // ====== Firebase init ======
    const firebaseConfig = {
      apiKey: "AIzaSyA_BFJ14tQMhgNVcyTyi4tU02wBl8yBovU",
      authDomain: "carte-perimetre.firebaseapp.com",
      databaseURL: "https://carte-perimetre-default-rtdb.firebaseio.com",
      projectId: "carte-perimetre",
      storageBucket: "carte-perimetre.firebasestorage.app",
      messagingSenderId: "1018235415713",
      appId: "1:1018235415713:web:52a1fb416e121617fcd4e0",
      measurementId: "G-0YVPM0KFXB"
    };
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    // Auth anonyme + couleur par utilisateur
    const myColor = (()=>{
      const palette = ['#ffd43b','#4dabf7','#69db7c','#ff8787','#b197fc','#f783ac','#74c0fc','#63e6be'];
      return palette[Math.floor(Math.random()*palette.length)];
    })();
    let myUid = null;
    auth.signInAnonymously().catch(console.error);
    auth.onAuthStateChanged(u=>{ myUid = u ? u.uid : null; });

    // DÃ©finir la couleur par dÃ©faut du sÃ©lecteur sur la couleur d'utilisateur
    if (drawColorEl) { drawColorEl.value = myColor; }

    // ====== Collaboration by room code ======
    let roomRef = null;           // /rooms/{code}
    let syncing = false;          // avoid feedback loops

    // PrÃ©sence temps rÃ©el
    function setupPresence(code){
      const presenceRoot = db.ref('rooms/'+code+'/presence');
      presenceRoot.on('value', snap =>{
        const n = snap.exists() ? Object.keys(snap.val()).length : 0;
        roomInfo.textContent = 'Session: '+code+' â€” '+n+' en ligne';
      });
      function setSelfPresence(){
        if(!myUid) return;
        const selfRef = presenceRoot.child(myUid);
        selfRef.set({ since: firebase.database.ServerValue.TIMESTAMP, color: myColor });
        selfRef.onDisconnect().remove();
      }
      if(myUid){
        setSelfPresence();
      } else {
        const unsub = auth.onAuthStateChanged(u=>{
          myUid = u ? u.uid : null;
          if(myUid){ setSelfPresence(); if(typeof unsub==='function') unsub(); }
        });
      }
    }

    function exportDrawingsGeoJSON(){
      const fc = { type:'FeatureCollection', features: [] };
      drawLayer.eachLayer(l =>{
        let gj = (l.toGeoJSON && l.toGeoJSON()) || null;
        if(!gj) return;
        if(!gj.properties) gj.properties = {};
        gj.properties.color = (l.options && (l.options.color || l.options.fillColor)) || '#ffd43b';
        if(myUid) gj.properties.author = myUid;
        fc.features.push(gj);
      });
      return fc;
    }
    function currentState(){
      return {
        center: centerMarker ? centerMarker.getLatLng() : map.getCenter(),
        radius: Math.max(50, parseInt(radiusEl.value,10) || 300),
        pois: pois,
        drawings: exportDrawingsGeoJSON()
      };
    }

    function applyState(s){
      syncing = true;
      try{
        if(!s) return;
        const R = Math.max(50, parseInt(s.radius, 10) || 300);
        const C = s.center || map.getCenter();

        if(centerMarker){ map.removeLayer(centerMarker); }
        if(circle){ map.removeLayer(circle); }
        centerMarker = L.marker([C.lat, C.lng], {
          draggable: true,
          icon: L.divIcon({ className: '', html: '<div class="pin"></div>', iconSize: [16,16], iconAnchor: [8,8] })
        }).addTo(map);
        circle = L.circle([C.lat, C.lng], {
          radius: R, color: '#ff3b30', weight:3, fillColor:'#ff3b30', fillOpacity:.25, renderer: L.canvas()
        }).addTo(map);
        centerMarker.on('drag', ()=>{ circle.setLatLng(centerMarker.getLatLng()); });
        centerMarker.on('dragend', ()=>{ circle.setLatLng(centerMarker.getLatLng()); pushState(); });
        radiusEl.value = R;

        pois = Array.isArray(s.pois) ? s.pois : [];
        rebuildPoiLayers();
        renderPoiList();

        drawLayer.clearLayers();
        if(s.drawings){
          L.geoJSON(s.drawings, {
            style: f => ({ color: f.properties?.color || '#ffd43b', weight: 6, opacity: 0.9, fillOpacity: 0.0 })
          }).eachLayer(l => drawLayer.addLayer(l));
          history = [s.drawings];
          histIdx = 0;
          updateUndoRedoButtons();
        }
      } finally {
        syncing = false;
      }
    }

    function pushState(){
      if(!roomRef || syncing) return;
      const s = currentState();
      roomRef.child('state').set(s);
    }

    function joinRoom(code){
      if(!code) { roomRef = null; roomInfo.textContent = 'Hors session'; return; }
      roomRef = db.ref('rooms/'+code);
      roomInfo.textContent = 'Session: '+code+' â€” connexionâ€¦';
      setupPresence(code);
      roomRef.child('state').on('value', snap => { const s = snap.val(); if(s) applyState(s); });
      roomRef.child('state').once('value').then(snap => { if(!snap.exists()){ pushState(); } });
    }

    // === Auto-join via ?room=... (ex: ?room=MASC-42)
    (function(){
      const params = new URLSearchParams(location.search);
      const roomFromUrl = params.get('room');
      if (roomFromUrl) {
        roomEl.value = roomFromUrl;
        joinRoom(roomFromUrl);
      }
    })();

    // === Share button: copie un lien prÃªt Ã  partager avec ?room=
    const shareBtn = document.getElementById('share');
    if (shareBtn) {
      shareBtn.addEventListener('click', async ()=>{
        const code = roomEl.value.trim();
        if (!code) { setStatus('Entrez un code de session avant de partager.'); return; }
        const url = new URL(location.href);
        url.searchParams.set('room', code);
        try {
          await navigator.clipboard.writeText(url.toString());
          setStatus('Lien copiÃ© dans le presse-papiers.');
        } catch {
          prompt('Copiez ce lien :', url.toString());
        }
      });
    }

    joinBtn.addEventListener('click', ()=>{
      const code = roomEl.value.trim();
      if(!code){ roomRef = null; roomInfo.textContent = 'Hors session'; return; }
      roomInfo.textContent = 'Session: '+code+' â€” connexionâ€¦';
      joinRoom(code);
    });

    // ====== Geocode (priorise Mascouche) ======
    async function geocode(q){
      const lang = (navigator.language || 'fr-CA');
      const base = new URL('https://nominatim.openstreetmap.org/search');
      base.searchParams.set('format','jsonv2'); base.searchParams.set('limit','1'); base.searchParams.set('accept-language', lang);
      const VB_LEFT=-73.72, VB_TOP=45.82, VB_RIGHT=-73.48, VB_BOTTOM=45.67; // Mascouche
      async function fetchOnce(u){ const r=await fetch(u.toString(),{headers:{'Accept':'application/json'}}); if(!r.ok) return null; const j=await r.json(); return (Array.isArray(j)&&j.length>0)?j[0]:null; }
      {
        const u=new URL(base); u.searchParams.set('q', q); u.searchParams.set('countrycodes','ca'); u.searchParams.set('viewbox', `${VB_LEFT},${VB_TOP},${VB_RIGHT},${VB_BOTTOM}`); u.searchParams.set('bounded','1');
        const hit=await fetchOnce(u); if(hit) return { lat:+hit.lat, lon:+hit.lon, display:hit.display_name };
      }
      {
        const u=new URL(base); u.searchParams.set('q', `${q}, Mascouche, QC`); u.searchParams.set('countrycodes','ca');
        const hit=await fetchOnce(u); if(hit) return { lat:+hit.lat, lon:+hit.lon, display:hit.display_name };
      }
      {
        const u=new URL(base); u.searchParams.set('q', q); u.searchParams.set('countrycodes','ca');
        const hit=await fetchOnce(u); if(hit) return { lat:+hit.lat, lon:+hit.lon, display:hit.display_name };
      }
      {
        const u=new URL(base); u.searchParams.set('q', q);
        const hit=await fetchOnce(u); if(hit) return { lat:+hit.lat, lon:+hit.lon, display:hit.display_name };
      }
      throw new Error('Adresse introuvable');
    }

    // ====== Circle & center ======
    function draw(lat, lon, radius, draggable = true){
      if (centerMarker) { map.removeLayer(centerMarker); }
      if (circle) { map.removeLayer(circle); }
      const icon = L.divIcon({ className: '', html: '<div class="pin"></div>', iconSize: [16,16], iconAnchor: [8,8] });
      centerMarker = L.marker([lat, lon], { draggable: !!draggable, icon });
      circle = L.circle([lat, lon], { radius: radius, color:'#ff3b30', weight:3, fillColor:'#ff3b30', fillOpacity:.25, renderer:L.canvas() });
      centerMarker.addTo(map); circle.addTo(map);
      if (draggable){
        centerMarker.on('drag', ()=>{ circle.setLatLng(centerMarker.getLatLng()); });
        centerMarker.on('dragend', ()=>{ circle.setLatLng(centerMarker.getLatLng()); pushState(); });
      }
      map.fitBounds(circle.getBounds(), { padding: [30,30] });
    }

    function canCreateCircleNow(){
      return !addrEl.value.trim() && !circle;
    }

    // ====== POIs ======
    function renderPoiList(){ if(!poiListEl) return; poiListEl.innerHTML = pois.map((p,i)=>`<div class="poi-item"><span class="dot" style="background:${p.color}"></span>${p.name||('Point '+(i+1))}<span style="flex:1"></span><button class="del" data-i="${i}">Supprimer</button></div>`).join(''); }
    function rebuildPoiLayers(){ poiLayer.clearLayers(); pois.forEach(p=>{ const cm=L.circleMarker([p.lat,p.lon],{radius:6,color:p.color,weight:2,fillColor:p.color,fillOpacity:1,renderer:L.canvas()}).addTo(poiLayer); if(p.name){ cm.bindTooltip(p.name,{permanent:true,direction:'right',offset:[10,0]}); } }); }
    function addPoi(lat, lon, name, color){ pois.push({lat, lon, name: name||'', color: color||'#ff3b30'}); rebuildPoiLayers(); renderPoiList(); pushState(); }

    // ====== Search/run ======
    async function run(){
      const q = addrEl.value.trim();
      const radius = Math.max(50, parseInt(radiusEl.value, 10) || 300);
      if(!q){ addrEl.focus(); return; }
      setStatus('GÃ©ocodageâ€¦'); searchBtn.disabled = true;
      try{
        const p = await geocode(q); setStatus('TrouvÃ© : ' + p.display);
        draw(p.lat, p.lon, radius); pushState();
      }catch(err){ console.error(err); setStatus('Erreur : ' + err.message); }
      finally{ searchBtn.disabled = false; }
    }

    // ====== Export PNG (Lettre paysage 300 DPI) ======
    async function exportPNG(){
      setStatus('GÃ©nÃ©ration du PNGâ€¦'); exportBtn.disabled = true;
      try{
        if (typeof window.leafletImage !== 'function') throw new Error('Module dâ€™export non chargÃ©');
        const hadCenter = !!(centerMarker && map.hasLayer(centerMarker));
        const centerBackup = (hadCenter && centerMarker.getLatLng()) ? centerMarker.getLatLng() : null;
        if (hadCenter) { map.removeLayer(centerMarker); }

        // Pour Ã©viter les soucis CORS lors de l'export, on force temporairement OSM light (CORS-friendly)
        const prevBase = currentBase;
        if (prevBase !== osmLight) setBase(osmLight);

        window.leafletImage(map, function(err, canvas){
          // Restaurer le fond initial
          if (prevBase && prevBase !== osmLight) setBase(prevBase);
          if (hadCenter && centerBackup) { centerMarker.setLatLng(centerBackup); centerMarker.addTo(map); }
          if(err){ setStatus('Ã‰chec de lâ€™export : ' + err.message); exportBtn.disabled = false; return; }
          try{
            const ctx = canvas.getContext('2d');
            // ==== Dessins (Leaflet.draw) : peindre explicitement sur le canvas ====
            (function renderDrawings(){
              function pathFromLatLngs(latlngs, close){
                if(!Array.isArray(latlngs) || latlngs.length===0) return;
                const first = map.latLngToContainerPoint(latlngs[0]);
                ctx.beginPath();
                ctx.moveTo(first.x, first.y);
                for(let i=1;i<latlngs.length;i++){
                  const p = map.latLngToContainerPoint(latlngs[i]);
                  ctx.lineTo(p.x, p.y);
                }
                if(close) ctx.closePath();
              }
              drawLayer.eachLayer(l=>{
                const opt = l.options||{};
                const color = opt.color || opt.fillColor || '#ffd43b';
                const weight = Math.max(1, opt.weight||2);
                if(l instanceof L.Polyline && !(l instanceof L.Polygon)){
                  const latlngs = l.getLatLngs();
                  const parts = Array.isArray(latlngs[0]) ? latlngs : [latlngs];
                  parts.forEach(seg=>{
                    pathFromLatLngs(seg, false);
                    ctx.lineWidth = weight; ctx.strokeStyle = color; ctx.globalAlpha = opt.opacity ?? 1; ctx.stroke(); ctx.globalAlpha = 1;
                  });
                } else if(l instanceof L.Polygon){
                  const rings = l.getLatLngs();
                  rings.forEach(ring=>{
                    const poly = Array.isArray(ring[0]) ? ring : [ring];
                    poly.forEach(r=>{
                      pathFromLatLngs(r, true);
                      if(opt.fill !== false){ ctx.fillStyle = (opt.fillColor||color); ctx.globalAlpha = opt.fillOpacity ?? 0.3; ctx.fill(); ctx.globalAlpha = 1; }
                      ctx.lineWidth = weight; ctx.strokeStyle = color; ctx.globalAlpha = opt.opacity ?? 1; ctx.stroke(); ctx.globalAlpha = 1;
                    });
                  });
                }
              });
            })();

            // ==== Cercle rayon (dessinÃ© manuellement) ====
            let centerLL = circle?.getLatLng?.() || centerBackup || map.getCenter();
            const radiusMeters = Math.max(50, parseInt(radiusEl.value,10) || 300);
            const R = 6378137; const toRad = d=>d*Math.PI/180; const toDeg = r=>r*180/Math.PI;
            function destPoint(lat,lng,dist,bearing){ const Î´=dist/R, Î¸=toRad(bearing), Ï†1=toRad(lat), Î»1=toRad(lng); const sinÏ†1=Math.sin(Ï†1), cosÏ†1=Math.cos(Ï†1), sinÎ´=Math.sin(Î´), cosÎ´=Math.cos(Î´); const sinÏ†2=sinÏ†1*cosÎ´ + cosÏ†1*sinÎ´*Math.cos(Î¸); const Ï†2=Math.asin(sinÏ†2); const y=Math.sin(Î¸)*sinÎ´*cosÏ†1; const x=cosÎ´ - sinÏ†1*sinÏ†2; const Î»2=Î»1+Math.atan2(y,x); return {lat:toDeg(Ï†2), lng:((toDeg(Î»2)+540)%360)-180}; }
            const centerPt = map.latLngToContainerPoint(centerLL); const eastLL = destPoint(centerLL.lat, centerLL.lng, radiusMeters, 90); const eastPt = map.latLngToContainerPoint(eastLL); const pixelRadius = Math.hypot(eastPt.x-centerPt.x, eastPt.y-centerPt.y);
            ctx.save(); ctx.beginPath(); ctx.arc(centerPt.x, centerPt.y, pixelRadius, 0, Math.PI*2); ctx.fillStyle='rgba(255,59,48,0.25)'; ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='#ff3b30'; ctx.stroke(); ctx.restore();

            // Draw POIs (markers + labels)
            if (Array.isArray(pois)){
              pois.forEach(p=>{ const pt = map.latLngToContainerPoint([p.lat,p.lon]); ctx.save(); ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI*2); ctx.fillStyle=p.color||'#ff3b30'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.stroke(); ctx.restore(); if(p.name){ ctx.save(); ctx.font='16px sans-serif'; ctx.textBaseline='middle'; ctx.lineWidth='3'; ctx.strokeStyle='rgba(255,255,255,0.95)'; ctx.strokeText(p.name, pt.x+10, pt.y); ctx.fillStyle='#111'; ctx.fillText(p.name, pt.x+10, pt.y); ctx.restore(); } });
            }
            // Center dot
            ctx.save(); ctx.beginPath(); ctx.arc(centerPt.x, centerPt.y, 4, 0, Math.PI*2); ctx.fillStyle='#ff3b30'; ctx.fill(); ctx.restore();

            const DPI=300, W_IN=11, H_IN=8.5, MARGIN=0.5; const PAGE_W=Math.round(W_IN*DPI), PAGE_H=Math.round(H_IN*DPI); const INNER_W=Math.round((W_IN-2*MARGIN)*DPI), INNER_H=Math.round((H_IN-2*MARGIN)*DPI);
            const out=document.createElement('canvas'); out.width=PAGE_W; out.height=PAGE_H; const octx=out.getContext('2d'); octx.fillStyle='#ffffff'; octx.fillRect(0,0,PAGE_W,PAGE_H);
            const srcW=canvas.width, srcH=canvas.height; const scale=Math.min(INNER_W/srcW, INNER_H/srcH); const destW=Math.round(srcW*scale), destH=Math.round(srcH*scale); const destX=Math.round((PAGE_W-destW)/2), destY=Math.round((PAGE_H-destH)/2);
            octx.imageSmoothingQuality='high'; octx.drawImage(canvas,0,0,srcW,srcH,destX,destY,destW,destH);

            out.toBlob(function(blob){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.download='map-300m-letter-landscape-300dpi.png'; a.href=url; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(()=>URL.revokeObjectURL(url), 800); setStatus('PNG (Lettre paysage) tÃ©lÃ©chargÃ©.'); }, 'image/png');
          }catch(e){ setStatus('Exportation bloquÃ©e: ' + e.message); const dataUrl = canvas.toDataURL('image/png'); window.open(dataUrl, '_blank'); }
          exportBtn.disabled = false;
        });
      }catch(err){ console.error(err); setStatus('Erreur dâ€™export : ' + err.message); exportBtn.disabled = false; }
    }

    // ====== Draw events sync ======
    map.on(L.Draw.Event.CREATED, function (e) {
      // Si on Ã©tait en mode mesure, style et label de distance
      if (measuringActive && e.layer && e.layer.getLatLngs) {
        const latlngs = e.layer.getLatLngs();
        const flat = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
        const meters = Math.round(polylineLength(flat));
        if (e.layer.setStyle) e.layer.setStyle({ color:'#ffffff', weight:3, dashArray:'6,4', opacity:1 });
        if (e.layer.bindTooltip) e.layer.bindTooltip(`${meters} m`, { permanent:true, direction:'center' }).openTooltip();
        measuringActive = false;
        if (measureBtn) measureBtn.classList.remove('active');
        setStatus(`Mesure: ${meters} m`);
      } else {
        const c = (drawColorEl && drawColorEl.value) || myColor;
        if(e.layer && e.layer.setStyle){ e.layer.setStyle({ color: c, fillColor: c }); }
      }
      drawLayer.addLayer(e.layer); snapshotDrawings(); pushState();
    });

    map.on(L.Draw.Event.EDITED, function () { snapshotDrawings(); pushState(); });
    map.on(L.Draw.Event.DELETED, function () { snapshotDrawings(); pushState(); });
    map.on(L.Draw.Event.DRAWSTOP, function (e) {
      // Si on sort du mode polyline sans crÃ©er, rÃ©initialiser lâ€™Ã©tat de mesure
      if (e.layerType === 'polyline' && measuringActive) {
        measuringActive = false;
        if (measureBtn) measureBtn.classList.remove('active');
        setStatus('Mesure annulÃ©e.');
      }
    });

    // ====== UI events ======
    searchBtn.addEventListener('click', run);
    addrEl.addEventListener('keydown', e=>{ if(e.key==='Enter'){ run(); }});
    exportBtn.addEventListener('click', exportPNG);

    // Changement de couleur de dessin => mettre Ã  jour les options de la toolbar
    if (drawColorEl) {
      drawColorEl.addEventListener('input', applyDrawColor);
      applyDrawColor();
    }

    // Armement d'un ajout de POI au prochain clic sur la carte (toggle pour annuler si recliquÃ©)
    if (addPoiOnceBtn){
      addPoiOnceBtn.addEventListener('click', ()=>{
        if (addPoiArmed) {
          // Annuler
          addPoiArmed = false;
          if (poiHintEl) poiHintEl.textContent = '';
          addPoiOnceBtn.textContent = 'Ajouter';
          addPoiOnceBtn.disabled = false; // reste cliquable
          setStatus('Ajout de point annulÃ©.');
          return;
        }
        // Armer
        addPoiArmed = true;
        if (poiHintEl) poiHintEl.textContent = 'Cliquez sur la carte pour placer le point dâ€™intÃ©rÃªtâ€¦';
        addPoiOnceBtn.textContent = 'Ajouter (actif)';
        addPoiOnceBtn.disabled = false; // permettre dâ€™annuler en recliquant
        document.getElementById('map')?.scrollIntoView({behavior:'smooth', block:'center'});
      });
    }

    // Clic sur la carte : soit place le POI armÃ©, soit crÃ©e le cercle s'il n'existe pas encore
    map.on('click', (e)=>{
      if (addPoiArmed) {
        addPoi(e.latlng.lat, e.latlng.lng, poiNameEl.value.trim(), poiColorEl.value);
        addPoiArmed = false;
        if (poiHintEl) poiHintEl.textContent = 'Point dâ€™intÃ©rÃªt ajoutÃ©.';
        if (addPoiOnceBtn) { addPoiOnceBtn.textContent = 'Ajouter'; addPoiOnceBtn.disabled = false; }
        return;
      }
      if (canCreateCircleNow()){
        const r = Math.max(50, parseInt(radiusEl.value,10) || 300);
        draw(e.latlng.lat, e.latlng.lng, r, true);
        pushState();
      }
    });

    // Suppression d'un POI depuis la liste
    poiListEl.addEventListener('click', (e)=>{ if(e.target.classList.contains('del')){ const i=parseInt(e.target.dataset.i,10); if(!isNaN(i)){ pois.splice(i,1); rebuildPoiLayers(); renderPoiList(); pushState(); } } });

    // Permettre la mise Ã  jour du rayon en direct
    radiusEl.addEventListener('change', ()=>{
      const r = Math.max(50, parseInt(radiusEl.value,10) || 300);
      if(circle){ circle.setRadius(r); }
      pushState();
    });

    // ====== Reset complet (quitte la session et nettoie la page) ======
    function resetPage(){
      try{
        const code = roomEl.value.trim();
        if(code && myUid){ db.ref('rooms/'+code+'/presence/'+myUid).remove().catch(()=>{}); }
        if(roomRef){ roomRef.off(); roomRef = null; }
      }catch{ /* ignore */ }

      roomEl.value='';
      roomInfo.textContent='Hors session';

      // Nettoyer tous les calques et Ã©tats
      drawLayer.clearLayers();
      history = []; histIdx = -1; updateUndoRedoButtons();
      poiLayer.clearLayers();
      pois = []; renderPoiList();
      if(centerMarker){ map.removeLayer(centerMarker); centerMarker=null; }
      if(circle){ map.removeLayer(circle); circle=null; }

      // RÃ©initialiser les champs
      addrEl.value='';
      radiusEl.value=300;
      addPoiArmed = false;

      // Enlever ?room= de lâ€™URL
      try{
        const u = new URL(location.href);
        u.searchParams.delete('room');
        window.history.replaceState({},'',u);
      }catch{ /* ignore */ }

      setStatus('Page rÃ©initialisÃ©e. Hors session.');
    }
    resetBtn.addEventListener('click', ()=>{
      if(confirm('Tout rÃ©initialiser et quitter la session ?')) resetPage();
    });

    // ====== (Mini) tests runtime â€” smoke + extra ======
    function selfTests(){
      try{
        console.assert(typeof L !== 'undefined', 'Leaflet non chargÃ©');
        console.assert(map && typeof map.setView === 'function', 'Carte non initialisÃ©e');
        console.assert(typeof firebase !== 'undefined', 'Firebase non chargÃ©');
        console.assert(app && app.options && app.options.projectId === 'carte-perimetre', 'projectId inattendu');
        console.assert(typeof geocode === 'function', 'geocode manquant');
        console.assert(typeof exportPNG === 'function', 'exportPNG manquant');
        console.assert(document.getElementById('addPoiOnce'), 'Bouton Ajouter POI manquant');
        console.assert(document.querySelector('.leaflet-draw-toolbar'), 'Toolbar Leaflet.draw absente');
        console.assert(document.querySelector('.leaflet-draw-edit-remove'), 'Bouton supprimer (gomme) absent');
        console.assert(document.getElementById('drawColor'), 'SÃ©lecteur de couleur des dessins manquant');
        console.assert(typeof applyState === 'function', 'applyState manquant');
        console.assert(typeof pushState === 'function', 'pushState manquant');
        console.assert(typeof exportDrawingsGeoJSON === 'function', 'exportDrawingsGeoJSON manquant');
        console.assert(typeof canCreateCircleNow === 'function', 'canCreateCircleNow manquant');
        if(!circle && !addrEl.value.trim()){
          console.assert(canCreateCircleNow()===true, 'canCreateCircleNow devrait Ãªtre true sans cercle et sans adresse');
        }
        if(circle){
          console.assert(canCreateCircleNow()===false, 'canCreateCircleNow devrait Ãªtre false quand un cercle existe');
        }
        console.log('[SelfTests] OK');
      } catch (e) {
        console.warn('[SelfTests] Ã©chec:', e);
      }
    }
    window.addEventListener('load', ()=> setTimeout(selfTests, 200));

    // Aide debug : remonter les erreurs dans le statut
    window.addEventListener('error', (ev)=>{ setStatus('Erreur JS: '+ (ev.message||'inconnue')); });
    window.addEventListener('unhandledrejection', (ev)=>{ setStatus('Promesse rejetÃ©e: '+ (ev.reason?.message||ev.reason||'inconnue')); });

  })();
  </script>
</body>
</html>
